// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package stylist

import (
	"fmt"
	"strings"
)

const (
	// InputTypeArg is a InputType of type arg.
	InputTypeArg InputType = "arg"
	// InputTypeStdin is a InputType of type stdin.
	InputTypeStdin InputType = "stdin"
	// InputTypeVariadic is a InputType of type variadic.
	InputTypeVariadic InputType = "variadic"
)

var ErrInvalidInputType = fmt.Errorf("not a valid InputType, try [%s]", strings.Join(_InputTypeNames, ", "))

var _InputTypeNames = []string{
	string(InputTypeArg),
	string(InputTypeStdin),
	string(InputTypeVariadic),
}

// InputTypeNames returns a list of possible string values of InputType.
func InputTypeNames() []string {
	tmp := make([]string, len(_InputTypeNames))
	copy(tmp, _InputTypeNames)
	return tmp
}

// String implements the Stringer interface.
func (x InputType) String() string {
	return string(x)
}

// String implements the Stringer interface.
func (x InputType) IsValid() bool {
	_, err := ParseInputType(string(x))
	return err == nil
}

var _InputTypeValue = map[string]InputType{
	"arg":      InputTypeArg,
	"stdin":    InputTypeStdin,
	"variadic": InputTypeVariadic,
}

// ParseInputType attempts to convert a string to a InputType.
func ParseInputType(name string) (InputType, error) {
	if x, ok := _InputTypeValue[name]; ok {
		return x, nil
	}
	return InputType(""), fmt.Errorf("%s is %w", name, ErrInvalidInputType)
}

// MarshalText implements the text marshaller method.
func (x InputType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *InputType) UnmarshalText(text []byte) error {
	tmp, err := ParseInputType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// OutputTypeJson is a OutputType of type json.
	OutputTypeJson OutputType = "json"
	// OutputTypeNone is a OutputType of type none.
	OutputTypeNone OutputType = "none"
	// OutputTypeRegexp is a OutputType of type regexp.
	OutputTypeRegexp OutputType = "regexp"
	// OutputTypeSarif is a OutputType of type sarif.
	OutputTypeSarif OutputType = "sarif"
)

var ErrInvalidOutputType = fmt.Errorf("not a valid OutputType, try [%s]", strings.Join(_OutputTypeNames, ", "))

var _OutputTypeNames = []string{
	string(OutputTypeJson),
	string(OutputTypeNone),
	string(OutputTypeRegexp),
	string(OutputTypeSarif),
}

// OutputTypeNames returns a list of possible string values of OutputType.
func OutputTypeNames() []string {
	tmp := make([]string, len(_OutputTypeNames))
	copy(tmp, _OutputTypeNames)
	return tmp
}

// String implements the Stringer interface.
func (x OutputType) String() string {
	return string(x)
}

// String implements the Stringer interface.
func (x OutputType) IsValid() bool {
	_, err := ParseOutputType(string(x))
	return err == nil
}

var _OutputTypeValue = map[string]OutputType{
	"json":   OutputTypeJson,
	"none":   OutputTypeNone,
	"regexp": OutputTypeRegexp,
	"sarif":  OutputTypeSarif,
}

// ParseOutputType attempts to convert a string to a OutputType.
func ParseOutputType(name string) (OutputType, error) {
	if x, ok := _OutputTypeValue[name]; ok {
		return x, nil
	}
	return OutputType(""), fmt.Errorf("%s is %w", name, ErrInvalidOutputType)
}

// MarshalText implements the text marshaller method.
func (x OutputType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *OutputType) UnmarshalText(text []byte) error {
	tmp, err := ParseOutputType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ProcessorTypeFormatter is a ProcessorType of type formatter.
	ProcessorTypeFormatter ProcessorType = "formatter"
	// ProcessorTypeLinter is a ProcessorType of type linter.
	ProcessorTypeLinter ProcessorType = "linter"
)

var ErrInvalidProcessorType = fmt.Errorf("not a valid ProcessorType, try [%s]", strings.Join(_ProcessorTypeNames, ", "))

var _ProcessorTypeNames = []string{
	string(ProcessorTypeFormatter),
	string(ProcessorTypeLinter),
}

// ProcessorTypeNames returns a list of possible string values of ProcessorType.
func ProcessorTypeNames() []string {
	tmp := make([]string, len(_ProcessorTypeNames))
	copy(tmp, _ProcessorTypeNames)
	return tmp
}

// String implements the Stringer interface.
func (x ProcessorType) String() string {
	return string(x)
}

// String implements the Stringer interface.
func (x ProcessorType) IsValid() bool {
	_, err := ParseProcessorType(string(x))
	return err == nil
}

var _ProcessorTypeValue = map[string]ProcessorType{
	"formatter": ProcessorTypeFormatter,
	"linter":    ProcessorTypeLinter,
}

// ParseProcessorType attempts to convert a string to a ProcessorType.
func ParseProcessorType(name string) (ProcessorType, error) {
	if x, ok := _ProcessorTypeValue[name]; ok {
		return x, nil
	}
	return ProcessorType(""), fmt.Errorf("%s is %w", name, ErrInvalidProcessorType)
}

// MarshalText implements the text marshaller method.
func (x ProcessorType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ProcessorType) UnmarshalText(text []byte) error {
	tmp, err := ParseProcessorType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ResultLevelNone is a ResultLevel of type none.
	ResultLevelNone ResultLevel = "none"
	// ResultLevelNote is a ResultLevel of type note.
	ResultLevelNote ResultLevel = "note"
	// ResultLevelWarning is a ResultLevel of type warning.
	ResultLevelWarning ResultLevel = "warning"
	// ResultLevelError is a ResultLevel of type error.
	ResultLevelError ResultLevel = "error"
)

var ErrInvalidResultLevel = fmt.Errorf("not a valid ResultLevel, try [%s]", strings.Join(_ResultLevelNames, ", "))

var _ResultLevelNames = []string{
	string(ResultLevelNone),
	string(ResultLevelNote),
	string(ResultLevelWarning),
	string(ResultLevelError),
}

// ResultLevelNames returns a list of possible string values of ResultLevel.
func ResultLevelNames() []string {
	tmp := make([]string, len(_ResultLevelNames))
	copy(tmp, _ResultLevelNames)
	return tmp
}

// String implements the Stringer interface.
func (x ResultLevel) String() string {
	return string(x)
}

// String implements the Stringer interface.
func (x ResultLevel) IsValid() bool {
	_, err := ParseResultLevel(string(x))
	return err == nil
}

var _ResultLevelValue = map[string]ResultLevel{
	"none":    ResultLevelNone,
	"note":    ResultLevelNote,
	"warning": ResultLevelWarning,
	"error":   ResultLevelError,
}

// ParseResultLevel attempts to convert a string to a ResultLevel.
func ParseResultLevel(name string) (ResultLevel, error) {
	if x, ok := _ResultLevelValue[name]; ok {
		return x, nil
	}
	return ResultLevel(""), fmt.Errorf("%s is %w", name, ErrInvalidResultLevel)
}

// MarshalText implements the text marshaller method.
func (x ResultLevel) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ResultLevel) UnmarshalText(text []byte) error {
	tmp, err := ParseResultLevel(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
