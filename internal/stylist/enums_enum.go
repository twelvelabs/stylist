// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package stylist

import (
	"fmt"
	"strings"
)

const (
	// InputTypeArg is a InputType of type arg.
	InputTypeArg InputType = "arg"
	// InputTypeStdin is a InputType of type stdin.
	InputTypeStdin InputType = "stdin"
	// InputTypeVariadic is a InputType of type variadic.
	InputTypeVariadic InputType = "variadic"
)

var ErrInvalidInputType = fmt.Errorf("not a valid InputType, try [%s]", strings.Join(_InputTypeNames, ", "))

var _InputTypeNames = []string{
	string(InputTypeArg),
	string(InputTypeStdin),
	string(InputTypeVariadic),
}

// InputTypeNames returns a list of possible string values of InputType.
func InputTypeNames() []string {
	tmp := make([]string, len(_InputTypeNames))
	copy(tmp, _InputTypeNames)
	return tmp
}

// String implements the Stringer interface.
func (x InputType) String() string {
	return string(x)
}

// String implements the Stringer interface.
func (x InputType) IsValid() bool {
	_, err := ParseInputType(string(x))
	return err == nil
}

var _InputTypeValue = map[string]InputType{
	"arg":      InputTypeArg,
	"stdin":    InputTypeStdin,
	"variadic": InputTypeVariadic,
}

// ParseInputType attempts to convert a string to a InputType.
func ParseInputType(name string) (InputType, error) {
	if x, ok := _InputTypeValue[name]; ok {
		return x, nil
	}
	return InputType(""), fmt.Errorf("%s is %w", name, ErrInvalidInputType)
}

// MarshalText implements the text marshaller method.
func (x InputType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *InputType) UnmarshalText(text []byte) error {
	tmp, err := ParseInputType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// OutputFormatJson is a OutputFormat of type json.
	OutputFormatJson OutputFormat = "json"
	// OutputFormatNone is a OutputFormat of type none.
	OutputFormatNone OutputFormat = "none"
	// OutputFormatRegexp is a OutputFormat of type regexp.
	OutputFormatRegexp OutputFormat = "regexp"
	// OutputFormatSarif is a OutputFormat of type sarif.
	OutputFormatSarif OutputFormat = "sarif"
)

var ErrInvalidOutputFormat = fmt.Errorf("not a valid OutputFormat, try [%s]", strings.Join(_OutputFormatNames, ", "))

var _OutputFormatNames = []string{
	string(OutputFormatJson),
	string(OutputFormatNone),
	string(OutputFormatRegexp),
	string(OutputFormatSarif),
}

// OutputFormatNames returns a list of possible string values of OutputFormat.
func OutputFormatNames() []string {
	tmp := make([]string, len(_OutputFormatNames))
	copy(tmp, _OutputFormatNames)
	return tmp
}

// String implements the Stringer interface.
func (x OutputFormat) String() string {
	return string(x)
}

// String implements the Stringer interface.
func (x OutputFormat) IsValid() bool {
	_, err := ParseOutputFormat(string(x))
	return err == nil
}

var _OutputFormatValue = map[string]OutputFormat{
	"json":   OutputFormatJson,
	"none":   OutputFormatNone,
	"regexp": OutputFormatRegexp,
	"sarif":  OutputFormatSarif,
}

// ParseOutputFormat attempts to convert a string to a OutputFormat.
func ParseOutputFormat(name string) (OutputFormat, error) {
	if x, ok := _OutputFormatValue[name]; ok {
		return x, nil
	}
	return OutputFormat(""), fmt.Errorf("%s is %w", name, ErrInvalidOutputFormat)
}

// MarshalText implements the text marshaller method.
func (x OutputFormat) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *OutputFormat) UnmarshalText(text []byte) error {
	tmp, err := ParseOutputFormat(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// OutputTypeStdout is a OutputType of type stdout.
	OutputTypeStdout OutputType = "stdout"
	// OutputTypeStderr is a OutputType of type stderr.
	OutputTypeStderr OutputType = "stderr"
)

var ErrInvalidOutputType = fmt.Errorf("not a valid OutputType, try [%s]", strings.Join(_OutputTypeNames, ", "))

var _OutputTypeNames = []string{
	string(OutputTypeStdout),
	string(OutputTypeStderr),
}

// OutputTypeNames returns a list of possible string values of OutputType.
func OutputTypeNames() []string {
	tmp := make([]string, len(_OutputTypeNames))
	copy(tmp, _OutputTypeNames)
	return tmp
}

// String implements the Stringer interface.
func (x OutputType) String() string {
	return string(x)
}

// String implements the Stringer interface.
func (x OutputType) IsValid() bool {
	_, err := ParseOutputType(string(x))
	return err == nil
}

var _OutputTypeValue = map[string]OutputType{
	"stdout": OutputTypeStdout,
	"stderr": OutputTypeStderr,
}

// ParseOutputType attempts to convert a string to a OutputType.
func ParseOutputType(name string) (OutputType, error) {
	if x, ok := _OutputTypeValue[name]; ok {
		return x, nil
	}
	return OutputType(""), fmt.Errorf("%s is %w", name, ErrInvalidOutputType)
}

// MarshalText implements the text marshaller method.
func (x OutputType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *OutputType) UnmarshalText(text []byte) error {
	tmp, err := ParseOutputType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ResultLevelNone is a ResultLevel of type none.
	ResultLevelNone ResultLevel = "none"
	// ResultLevelNote is a ResultLevel of type note.
	ResultLevelNote ResultLevel = "note"
	// ResultLevelWarning is a ResultLevel of type warning.
	ResultLevelWarning ResultLevel = "warning"
	// ResultLevelError is a ResultLevel of type error.
	ResultLevelError ResultLevel = "error"
)

var ErrInvalidResultLevel = fmt.Errorf("not a valid ResultLevel, try [%s]", strings.Join(_ResultLevelNames, ", "))

var _ResultLevelNames = []string{
	string(ResultLevelNone),
	string(ResultLevelNote),
	string(ResultLevelWarning),
	string(ResultLevelError),
}

// ResultLevelNames returns a list of possible string values of ResultLevel.
func ResultLevelNames() []string {
	tmp := make([]string, len(_ResultLevelNames))
	copy(tmp, _ResultLevelNames)
	return tmp
}

// String implements the Stringer interface.
func (x ResultLevel) String() string {
	return string(x)
}

// String implements the Stringer interface.
func (x ResultLevel) IsValid() bool {
	_, err := ParseResultLevel(string(x))
	return err == nil
}

var _ResultLevelValue = map[string]ResultLevel{
	"none":    ResultLevelNone,
	"note":    ResultLevelNote,
	"warning": ResultLevelWarning,
	"error":   ResultLevelError,
}

// ParseResultLevel attempts to convert a string to a ResultLevel.
func ParseResultLevel(name string) (ResultLevel, error) {
	if x, ok := _ResultLevelValue[name]; ok {
		return x, nil
	}
	return ResultLevel(""), fmt.Errorf("%s is %w", name, ErrInvalidResultLevel)
}

// MarshalText implements the text marshaller method.
func (x ResultLevel) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ResultLevel) UnmarshalText(text []byte) error {
	tmp, err := ParseResultLevel(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
